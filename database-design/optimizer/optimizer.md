# 什么是优化器

​		数据库使用者一般使用SQL作为与数据库交流的语言。作为一种声明式语言，SQL简单且贴合人类的思维方式，但数据库需要基于SQL描述的目标，在内部建立一个真正可以获取或修改数据的执行方式，这个工作就是由优化器来完成的。 优化器本质上是一个搜索器，最粗暴的做法是，我们可以把所有数据的访问方式，各个表的相互join方式、join顺序、各个算子的执行方式等全部枚举+组合起来，形成一组执行计划，然后为每个执行计划估算一个代价，选择其中最优的执行计划作为执行方案。



# 架构篇

当前主流的优化器框架有两种，bottom-up和top-down。

### bottom-up

bottom-up是最经典的框架，最早在System-R系统中被提出，例如Oracle、DB2、MySQL、PostgreSQL等数据库的优化器都属于这一类，整个优化器执行过程被分为了两个阶段：

   			1. 基于规则的查询改写，主要完成基于关系代数对原有抽象语法树树进行优化，生成更有利于执行的逻辑算子树
   			2. 基于代价的查询优化，对逻辑优化后的树进行物理优化，主要就是扫描方式以及join ordering和join方式的确定，此外还有其他算子的计算方式的决定，这部分是基于代价的，需要依赖于统计信息和代价模型		

### top-down

较晚些出现的Volcano/Cascades优化框架，其思想是对优化策略做更好的抽象，从而不再需要显式的区分各种类型的查询优化（如谓词下推、join ordering等都统一视为优化规则）。然后基于一个统一的自顶向下的搜索策略来完成最优执行计划的搜索

top-down具有更好的抽象和扩展，也有更好的搜索效率

### bottom-up的缺点

bottom-up方式最大的特点是优化被比较明确的分为了两个阶段，逻辑优化 => 物理优化，逻辑优化阶段主要做一些启发式的查询改写，物理优化则主要解决join的顺序+算子执行方式这个问题，这就意味着：

1. 对于那些无法确定是否能够有效的查询改写动作（如子查询上拉），没有一个合适的时机去做，任何一个阶段都无法独立做出判断，决定一个改写策略是否是更优的
2. 物理优化阶段一般采用bottom-up的join ordering算法，这样是无法有针对性的完成基于物理属性的剪枝的

### top-down的缺点

top-down方式在理论上消除了bottom-up两个割裂的阶段，在一套枚举流程中完成查询改写+join ordering等各种优化，过程中考虑代价，这样也就解决了一些复杂的查询改写（如子查询上拉）无法基于代价确定其有效性的问题，这看起来相当完美，但问题则出在工程实践中：

1. top-down的搜索策略基于Memo完成逻辑、物理算子的创建和保存，但这个过程很不直观，这带来了调试bug和分析regression的复杂性，对于线上排查和维护会比较不方便
2. 如果把一些复杂改写也揉入到Memo的搜索框架中，会导致计划空间的爆炸性膨胀，拖慢优化时间，目前开源界比较流行的Cascades框架优化器，我只看到Orca有这种在搜索过程中考虑复杂查询改写的能力（而这也导致了其比较出名的优化效率问题），其他的top-down优化器仍然采用了类似bottom-up搜索的2阶段搞法，因此也就同样具有无法基于代价决定是否应用优化策略的问题



# 逻辑优化



# 物理优化

## 统计信息



## 基数估计



## 代价模型